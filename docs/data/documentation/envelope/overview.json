{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"Envelope"},{"type":"text","text":" type efficiently supports everything from enclosing the most basic of plaintext messages, to innumerable recursive permutations of encryption, signing, sharding, and representing semantic graphs. Here is its notional definition in Swift:"}]},{"type":"codeListing","syntax":"swift","code":["struct Envelope {","    let subject: Envelope","    let assertions: [Assertion]","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The basic idea is that an "},{"type":"codeVoice","code":"Envelope"},{"type":"text","text":" contains some "},{"type":"reference","isActive":true,"identifier":"https:\/\/www.rfc-editor.org\/rfc\/rfc8949.html#name-deterministically-encoded-c"},{"type":"text","text":" data (the "},{"type":"codeVoice","code":"subject"},{"type":"text","text":") that may or may not be encrypted or elided, and zero or more assertions about the "},{"type":"codeVoice","code":"subject"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Assertions combine two specific parts, "},{"type":"codeVoice","code":"subject"},{"type":"text","text":" and "},{"type":"codeVoice","code":"predicate"},{"type":"text","text":", both of which themselves are also of type "},{"type":"codeVoice","code":"Envelope"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["struct Assertion {","    let predicate: Envelope","    let object: Envelope","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Combining the "},{"type":"codeVoice","code":"subject"},{"type":"text","text":" of an "},{"type":"codeVoice","code":"Envelope"},{"type":"text","text":" with the "},{"type":"codeVoice","code":"predicate"},{"type":"text","text":" and "},{"type":"codeVoice","code":"object"},{"type":"text","text":" of an assertion forms a "},{"type":"reference","isActive":true,"identifier":"https:\/\/en.wikipedia.org\/wiki\/Semantic_triple"},{"type":"text","text":", which may be part of a larger "},{"type":"reference","isActive":true,"identifier":"https:\/\/en.wikipedia.org\/wiki\/Knowledge_graph"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This assertion-predicate-object triplet may be more easily understood by considering its linguistic usage:"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"overview1"}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"“Alice knows Bob.”"}]}],"type":"aside","name":"Note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"There can be any number assertions associated with each subject:"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"overview2"}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"“Alice knows Bob and dislikes Carol.”"}]}],"type":"aside","name":"Note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In “Envelope notation” the above would be written:"}]},{"type":"codeListing","syntax":null,"code":["\"Alice\" [","    \"knows\": \"Bob\"","    \"dislikes\": \"Carol\"","]"]},{"anchor":"Assertions","level":2,"type":"heading","text":"Assertions"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Assertions are themselves "},{"type":"codeVoice","code":"Envelope"},{"type":"text","text":"s, and can therefore be encrypted, elided, or carry assersions."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Within an assertion, the "},{"type":"codeVoice","code":"predicate"},{"type":"text","text":" and "},{"type":"codeVoice","code":"object"},{"type":"text","text":" are themselves "},{"type":"codeVoice","code":"Envelope"},{"type":"text","text":"s, and so they may also be encrypted or elided, or carry assertions."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It is therefore possible to hide any part of an "},{"type":"codeVoice","code":"Envelope"},{"type":"text","text":" or any of its assertions by encrypting or eliding its parts. Here is a simple example consisting of an "},{"type":"codeVoice","code":"Envelope"},{"type":"text","text":" whose "},{"type":"codeVoice","code":"subject"},{"type":"text","text":" is a simple text string, which has been signed."}]},{"type":"codeListing","syntax":null,"code":["\"Hello.\" [","    verifiedBy: Signature","]"]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"You can hide the "},{"type":"codeVoice","code":"subject"},{"type":"text","text":" about which assertions are made:"}]}]}]},{"type":"codeListing","syntax":null,"code":["ELIDED [","    verifiedBy: Signature","]"]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"You can hide the "},{"type":"codeVoice","code":"predicate"},{"type":"text","text":" to reveal that the "},{"type":"codeVoice","code":"subject"},{"type":"text","text":" and "},{"type":"codeVoice","code":"object"},{"type":"text","text":" are related, but hide "},{"type":"emphasis","inlineContent":[{"type":"text","text":"how"}]},{"type":"text","text":" they are related:"}]}]}]},{"type":"codeListing","syntax":null,"code":["\"Hello.\" [","    ELIDED: Signature","]"]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"You can hide the "},{"type":"codeVoice","code":"object"},{"type":"text","text":" to assert that the subject is related in a specific way to some other hidden object:"}]}]}]},{"type":"codeListing","syntax":null,"code":["\"Hello.\" [","    verifiedBy: ELIDED","]"]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"You can hide both parts of the assertion separately by hiding the "},{"type":"codeVoice","code":"subject"},{"type":"text","text":", "},{"type":"codeVoice","code":"predicate"},{"type":"text","text":", and "},{"type":"codeVoice","code":"object"},{"type":"text","text":", while still revealing that an assertion "},{"type":"emphasis","inlineContent":[{"type":"text","text":"exists"}]},{"type":"text","text":", and allowing verification of the digests of the two parts separately:"}]}]}]},{"type":"codeListing","syntax":null,"code":["\"Hello.\" [","    ELIDED: ELIDED","]"]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"You can hide a complete assertion, hiding the digests of the individual "},{"type":"codeVoice","code":"predicate"},{"type":"text","text":" and "},{"type":"codeVoice","code":"object"},{"type":"text","text":","}]}]}]},{"type":"codeListing","syntax":null,"code":["\"Hello.\" [","    ELIDED","]"]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Finally, you can hide even the fact of the assertion’s existence by encrypting or eliding the entire envelope, including its assertions."}]}]}]},{"type":"codeListing","syntax":null,"code":["ELIDED"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It is important to understand that because "},{"type":"codeVoice","code":"Envelope"},{"type":"text","text":" supports “complex metadata”, i.e., “assertions with assertions,” users are not limited to semantic triples. Adding context, as in a "},{"type":"reference","isActive":true,"identifier":"https:\/\/en.wikipedia.org\/wiki\/Named_graph#Named_graphs_and_quads"},{"type":"text","text":", is easily accomplished with an assertion on the subject."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In fact, any "},{"type":"codeVoice","code":"Envelope"},{"type":"text","text":" can also be an element of a "},{"type":"reference","isActive":true,"identifier":"https:\/\/en.wikipedia.org\/wiki\/Cons"},{"type":"text","text":", with the “first” element being the "},{"type":"codeVoice","code":"subject"},{"type":"text","text":" and the “rest” being the assertions. And since the "},{"type":"codeVoice","code":"subject"},{"type":"text","text":" of an "},{"type":"codeVoice","code":"Envelope"},{"type":"text","text":" can be any CBOR object, a "},{"type":"codeVoice","code":"subject"},{"type":"text","text":" can also be any structure (such as an array or map) containing other "},{"type":"codeVoice","code":"Envelope"},{"type":"text","text":"s."}]},{"anchor":"Digests","level":2,"type":"heading","text":"Digests"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Each "},{"type":"codeVoice","code":"Envelope"},{"type":"text","text":" produces an associated "},{"type":"codeVoice","code":"Digest"},{"type":"text","text":", such that if the "},{"type":"codeVoice","code":"subject"},{"type":"text","text":" and "},{"type":"codeVoice","code":"assertions"},{"type":"text","text":" of the "},{"type":"codeVoice","code":"Envelope"},{"type":"text","text":" are semantically identical, then the same "},{"type":"codeVoice","code":"Digest"},{"type":"text","text":" must necessarily be produced."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because hashing a concatenation of items is non-commutative, the order of the elements in the "},{"type":"codeVoice","code":"assertions"},{"type":"text","text":" array is determined by sorting them lexicographically by the "},{"type":"codeVoice","code":"Digest"},{"type":"text","text":" of each assertion, and disallowing identical assertions. Combined with the required use of "},{"overridingTitleInlineContent":[{"type":"text","text":"deterministically-encoded CBOR"}],"isActive":true,"type":"reference","identifier":"https:\/\/www.rfc-editor.org\/rfc\/rfc8949.html#name-deterministically-encoded-c","overridingTitle":"deterministically-encoded CBOR"},{"type":"text","text":", this ensures that an identical "},{"type":"codeVoice","code":"subject"},{"type":"text","text":" with identical "},{"type":"codeVoice","code":"assertions"},{"type":"text","text":" will yield the same "},{"type":"codeVoice","code":"Envelope"},{"type":"text","text":" digest, and "},{"type":"codeVoice","code":"Envelope"},{"type":"text","text":"s containing other "},{"type":"codeVoice","code":"Envelope"},{"type":"text","text":"s will yield the same digest tree, also called a "},{"type":"reference","isActive":true,"identifier":"https:\/\/en.wikipedia.org\/wiki\/Merkle_tree"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Envelopes can be be in several forms, for any of these forms, the same digest is present for the same binary object:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Present locally or referenced by a "},{"type":"codeVoice","code":"Digest"},{"type":"text","text":"."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Unencrypted or encrypted."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Unelided or elided."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Thus the "},{"type":"codeVoice","code":"Digest"},{"type":"text","text":" of an "},{"type":"codeVoice","code":"Envelope"},{"type":"text","text":" identifies the "},{"type":"codeVoice","code":"subject"},{"type":"text","text":" and its assertions as if they were all present (dereferenced), unelided, and unencrypted. This allows an "},{"type":"codeVoice","code":"Envelope"},{"type":"text","text":" to be transformed either into or out of the various encrypted\/decrypted, local\/reference, and elided\/unelided forms without changing the cumulative Merkle tree of digests. This also means that any transformations that do not preserve the digest tree invalidate the signatures of any enclosing "},{"type":"codeVoice","code":"Envelope"},{"type":"text","text":"s."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This architecture supports selective disclosure of contents of nested "},{"type":"codeVoice","code":"Envelope"},{"type":"text","text":"s by revealing only the minimal objects necessary to traverse to a particular nesting path, and having done so, calculating the hashes back to the root allows verification that the correct and included contents were disclosed. On a structure where only a minimal number of fields have been revealed, a signature can still be verified."}]},{"anchor":"CID","level":2,"type":"heading","text":"CID"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This proposal uses the "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/BlockchainCommons\/Research\/blob\/master\/papers\/bcr-2022-002-cid-common-identifier.md"},{"type":"text","text":" type as an analogue for a "},{"type":"reference","isActive":true,"identifier":"https:\/\/www.w3.org\/TR\/did-core"},{"type":"text","text":". Both "},{"type":"codeVoice","code":"CID"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Digest"},{"type":"text","text":" may be dereferenceable through some form of distributed ledger or registry. The main difference is that the dereferenced content of a "},{"type":"codeVoice","code":"CID"},{"type":"text","text":" may differ depending on what system dereferenced it or when it was dereferenced (in other words, it may be viewed as mutable), while a "},{"type":"codeVoice","code":"Digest"},{"type":"text","text":" always dereferences to a unique, immutable object."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Put another way, a "},{"type":"codeVoice","code":"CID"},{"type":"text","text":" resolves to a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"projection"}]},{"type":"text","text":" of a current view of an object, while a "},{"type":"codeVoice","code":"Digest"},{"type":"text","text":" resolves only to a specific immutable object."}]},{"anchor":"References","level":2,"type":"heading","text":"References"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the "},{"type":"reference","isActive":true,"identifier":"https:\/\/www.w3.org\/TR\/did-core\/"},{"type":"text","text":", a given DID URI is tied to a single specific method for resolving it. However, there are many cases where one may want a resource (possibly a DID document-like object) or third-party assertions about such a resource to persist in a multiplicity of places, retrievable by a multiplicity of methods. Therefore, in this proposal, one or more methods for dereferencing a "},{"type":"codeVoice","code":"CID"},{"type":"text","text":" or "},{"type":"codeVoice","code":"Digest"},{"type":"text","text":" (analogous to DID methods) may be added to an "},{"type":"codeVoice","code":"Envelope"},{"type":"text","text":" as assertions with the "},{"type":"codeVoice","code":"dereferenceVia"},{"type":"text","text":" predicate. This allows the referent to potentially exist in many places (including local caches), with the assertions providing guidance to authoritative or recommended methods for dereferencing them."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/envelope\/overview"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/Envelope\/documentation\/Envelope\/Overview","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"A high-level introduction to Gordian Envelope."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Envelope Overview","role":"article","modules":[{"name":"Envelope"}]},"hierarchy":{"paths":[["doc:\/\/Envelope\/documentation\/Envelope"]]},"seeAlsoSections":[{"title":"Essentials","identifiers":["doc:\/\/Envelope\/documentation\/Envelope\/Examples","doc:\/\/Envelope\/documentation\/Envelope\/Envelope"],"generated":true}],"references":{"https://en.wikipedia.org/wiki/Semantic_triple":{"title":"semantic triple","titleInlineContent":[{"type":"text","text":"semantic triple"}],"type":"link","identifier":"https:\/\/en.wikipedia.org\/wiki\/Semantic_triple","url":"https:\/\/en.wikipedia.org\/wiki\/Semantic_triple"},"https://www.rfc-editor.org/rfc/rfc8949.html#name-deterministically-encoded-c":{"title":"deterministically-encoded CBOR","titleInlineContent":[{"type":"text","text":"deterministically-encoded CBOR"}],"type":"link","identifier":"https:\/\/www.rfc-editor.org\/rfc\/rfc8949.html#name-deterministically-encoded-c","url":"https:\/\/www.rfc-editor.org\/rfc\/rfc8949.html#name-deterministically-encoded-c"},"https://github.com/BlockchainCommons/Research/blob/master/papers/bcr-2022-002-cid-common-identifier.md":{"title":"CID (Common Identifier)","titleInlineContent":[{"type":"codeVoice","code":"CID"},{"type":"text","text":" (Common Identifier)"}],"type":"link","identifier":"https:\/\/github.com\/BlockchainCommons\/Research\/blob\/master\/papers\/bcr-2022-002-cid-common-identifier.md","url":"https:\/\/github.com\/BlockchainCommons\/Research\/blob\/master\/papers\/bcr-2022-002-cid-common-identifier.md"},"https://en.wikipedia.org/wiki/Named_graph#Named_graphs_and_quads":{"title":"semantic quad","titleInlineContent":[{"type":"text","text":"semantic quad"}],"type":"link","identifier":"https:\/\/en.wikipedia.org\/wiki\/Named_graph#Named_graphs_and_quads","url":"https:\/\/en.wikipedia.org\/wiki\/Named_graph#Named_graphs_and_quads"},"https://www.w3.org/TR/did-core/":{"title":"DID spec","titleInlineContent":[{"type":"text","text":"DID spec"}],"type":"link","identifier":"https:\/\/www.w3.org\/TR\/did-core\/","url":"https:\/\/www.w3.org\/TR\/did-core\/"},"doc://Envelope/documentation/Envelope":{"role":"collection","title":"Envelope","abstract":[{"type":"text","text":"Gordian Envelope: A flexible container for structured data."}],"identifier":"doc:\/\/Envelope\/documentation\/Envelope","kind":"symbol","type":"topic","url":"\/documentation\/envelope"},"doc://Envelope/documentation/Envelope/Envelope":{"role":"symbol","title":"Envelope","fragments":[{"kind":"keyword","text":"enum"},{"kind":"text","text":" "},{"kind":"identifier","text":"Envelope"}],"abstract":[{"type":"text","text":"A flexible container for structured data."}],"identifier":"doc:\/\/Envelope\/documentation\/Envelope\/Envelope","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Envelope"}],"url":"\/documentation\/envelope\/envelope"},"https://en.wikipedia.org/wiki/Knowledge_graph":{"title":"knowledge graph","titleInlineContent":[{"type":"text","text":"knowledge graph"}],"type":"link","identifier":"https:\/\/en.wikipedia.org\/wiki\/Knowledge_graph","url":"https:\/\/en.wikipedia.org\/wiki\/Knowledge_graph"},"overview2":{"alt":"Alice knows bob and dislikes Carol.","type":"image","identifier":"overview2","variants":[{"url":"\/images\/overview2.png","traits":["1x","light"]}]},"https://en.wikipedia.org/wiki/Merkle_tree":{"title":"Merkle tree","titleInlineContent":[{"type":"text","text":"Merkle tree"}],"type":"link","identifier":"https:\/\/en.wikipedia.org\/wiki\/Merkle_tree","url":"https:\/\/en.wikipedia.org\/wiki\/Merkle_tree"},"https://www.w3.org/TR/did-core":{"title":"DID (Decentralized Identifier)","titleInlineContent":[{"type":"text","text":"DID (Decentralized Identifier)"}],"type":"link","identifier":"https:\/\/www.w3.org\/TR\/did-core","url":"https:\/\/www.w3.org\/TR\/did-core"},"https://en.wikipedia.org/wiki/Cons":{"title":"cons pair","titleInlineContent":[{"type":"text","text":"cons pair"}],"type":"link","identifier":"https:\/\/en.wikipedia.org\/wiki\/Cons","url":"https:\/\/en.wikipedia.org\/wiki\/Cons"},"overview1":{"alt":"Alice knows bob.","type":"image","identifier":"overview1","variants":[{"url":"\/images\/overview1.png","traits":["1x","light"]}]},"doc://Envelope/documentation/Envelope/Examples":{"role":"article","title":"Examples","abstract":[{"type":"text","text":"High-level examples of API usage."}],"identifier":"doc:\/\/Envelope\/documentation\/Envelope\/Examples","kind":"article","type":"topic","url":"\/documentation\/envelope\/examples"}}}